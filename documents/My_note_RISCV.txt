The riscV terminology

--ISA		instruction-set architecture

--EEI		execution environment interface

--core

--harts // thread

--accelerator

--coprocesser

--XLEN		64 or 32


--risc-v standard

Base Integer Instruction Set
M	multiple/divide
A	atomic
F	float
D	double
C	compressed, 16 bits




--list of operations in calculation units
Arithmetic operations:
Add (ADD)
Add immediate (ADDI)
Subtract (SUB)
Subtract immediate (SUBI)
Multiply (MUL)
Multiply unsigned (MULU)
Divide (DIV)
Divide unsigned (DIVU)
Remainder (REM)
Remainder unsigned (REMU)

Logic operations:
And (AND)
Or (OR)
Exclusive-OR (XOR)
And immediate (ANDI)	
Or immediate (ORI)
Exclusive-OR immediate (XORI)
Shift left logical (SLL)
Shift right logical (SRL)
Shift right arithmetic (SRA)
Set if less than (SLT)
Set if less than unsigned (SLTU)

operations of calculation units:
1-ADD/SLT/SLTU
AND/OR/XOR
SLL/SRL
SUB/SRA

2-
ADDI/SLTI[U]
ANDI/ORI/XORI

3- SLLI
SRLI
SRAI

The operations need ALU 

R-TYPE
||funct7  |	rs2	 |	rs1	|	funct3	|  rd	|opcode||

1. ADD
	rs1 + rs2, save result in rd 	(addition)

2. SLT
	if(rs1 <s rs2) then rd <= 1; else rd <= 0;	(comparition with signed)

3. SLTU	
	if(rs1 <u rs2) then rd <= 1; else rd <= 0;	(comparition with unsigned)

4. AND
	rs1 & rs2, save result in rd	(Bitwise operation)

5. OR
	rs1 | rs2, save result in rd	(Bitwise operation)
	
6. XOR
	rs1 ^ rs2, save result in rd	(Bitwise operation)

7. SLL 
	rs1 << rs2, save result in rd	(Bitwise operation)

8. SRL
	rs1 >> rs2, save result in rd	(Bitwise operation)

9. SUB
	rs1 - rs2, save result in rd	(subtraction)

10. SRA
	rs1 >>s rs2, right shift by the lower 5 bits of rs2, and save result in rd	(Bitwise operation)
	
I-TYPE
||		imm[11:0]	 	|	rs1	 |	funct3	|  rd	|opcode||

1. ADDI
	rs1 + immediate, save result in rd	(addition)

2. SLTI
	if(rs1 <s immediate) then rs = 1, else rs = 0 	(comparition with signed)

3. SLTIU
	if(rs1 <u immediate) then rs = 1, else rs = 0 	(comparition with unsigned)
	
4. ANDI
	rs1 & immediate, save result in rd	(Bitwise operation)
	
5. ORI
	rs1 | immediate, save result in rd 	(Bitwise operation)

6. XORI
	rs1 ^ immediate, save result in rd 	(Bitwise operation)

7. SLLI
	rs1 << immediate, save result in rd	(Bitwise operation)

8. SLRI
	rs1 >> immediate, save result in rd	(Bitwise operation)

9.SRAI
	rs1 >>s immediate, save result in rd	(Bitwise operation)
	
10.LB(U)
	rd  <= sext ( M[rs1 + sext(immediate)] [7:0]]		(address calculation)
	
11.LH(U)
	rd  <= sext ( M[rs1 + sext(immediate)] [15:0]]		(address calculation)

12.LW
	rd  <= sext ( M[rs1 + sext(immediate)] [31:0]]		(address calculation)
	
13.JALR
	t = pc+4; pc = (rs1 + sext(immediate)) & ~1; rd = t			(pc addition, Bitwise operation)
	
S-TYPE
||	imm[11:5] 	|rs2	|	rs1	 |	funct3	|  imm[4:0]	|opcode||

1.SB
	M[rs1] + sext(immediate) => rs2[7:0]		(address calculation)

2.SH	
	M[rs1] + sext(immediate) => rs2[15:0]		(address calculation)

3.SW
	M[rs1] + sext(immediate) => rs2[31:0]		(address calculation)

B-TYPE
||	imm[12]		|	imm[10:5]	| rs2 |	rs1	 |	funct3	|  imm[4:1]	|	imm[11]	|opcode||

1.BEQ
	if(rs1 == rs2) then pc += sext(immediate)			(comparition, pc addition)

2.BNE
	if(rs1 != rs2) then pc += sext(immediate)			(comparition, pc addition)

3.BLT
	if(rs1 <s rs2) then pc += sext(immediate)			(comparition, pc addition)
	
4.BGE
	if(rs1 >=s rs2) then pc += sext(immediate)			(comparition, pc addition)

5.BLTU
	if(rs1 <u rs2) then pc += sext(immediate)			(comparition, pc addition)

6.BGEU
	if(rs1 >=u rs2) then pc += sext(immediate)			(comparition, pc addition)
	
U-TYPE
||	imm[31:12]	|	rd	|	opcode	||

1.LUI
	rd = sext(immediate[31:12]<<12)						(NO NEED)

2.AUIPC
	rd = pc + sext(immediate[31:12]<<12)				(pc addition)

J-TYPE
||	imm[20]	|	imm[10:1]	|	imm[11]		|	imm[19:12]	|	rd	|	opcode	||

1.JAL
	rd = pc + 4; pc += sext(immediate) 					(address calculation)
















notes about john's video

1.1 register x0 hardwired to 0,
	
	x1 -x31 general purpose registers 
	program counter (pc): to remember memory address where the program instruction are located.
	number of bits in each register is defined  by ISA (instruction set architecture)
	
	a hardware thread is a hart. In RISC-V CPU, a hart refers to the collection of 32 registers, instruction excution unit and ALU.
1.2 ISA
	RISC-V ISA is a set of modules.

RV Base modules
	RV32I(integer, 32-bit general purpose),RV32E(embedded, 16 registers), RV64I, RV128I
Extension Modules
	M(math) ,A(atomic) ,F(32-bit float point), D(64-bit fp) ,Q(128-bit fp),C(compressed size instruction), etc
	Extension G combined IMAFD, a common combination
	
1.3	How CPU execute a program

	process of executing a program is continuous repeats of a series of instruction cycles
	Fetch, Decode, Execute. 3 phases
	
2 RV32I
2.1 ADD,AND,ADDI,ANDI

	BRANCH: BE, BGE, BGEU, BLT, BLTU, BNE
	pc <= pc + ((rs1==rs2) ? imm_b : 4 )  signed imm_b is pcrel_13
	
2.2 Jump and Link (JAL) : rd <= pc+4, pc <= pc+imm_j
				  (JALR): rd <= pc+4, pc <= (rs1 + imm_i)&~1  (multipal of 4)
				
2.3	Load
	
	Load Byte, Load Byte Unsigned
	Load half word
	Load upper immediate
	Load word
	





			
	
