The riscV terminology

--ISA		instruction-set architecture

--EEI		execution environment interface

--core

--harts // thread

--accelerator

--coprocesser

--XLEN		64 or 32


--risc-v standard

Base Integer Instruction Set
M	multiple/divide
A	atomic
F	float
D	double
C	compressed, 16 bits


--list of operations in calculation units
Arithmetic operations:
Add (ADD)
Add immediate (ADDI)
Subtract (SUB)
Subtract immediate (SUBI)
Multiply (MUL)
Multiply unsigned (MULU)
Divide (DIV)
Divide unsigned (DIVU)
Remainder (REM)
Remainder unsigned (REMU)

Logic operations:
And (AND)
Or (OR)
Exclusive-OR (XOR)
And immediate (ANDI)	
Or immediate (ORI)
Exclusive-OR immediate (XORI)
Shift left logical (SLL)
Shift right logical (SRL)
Shift right arithmetic (SRA)
Set if less than (SLT)
Set if less than unsigned (SLTU)


operations of calculation units:
1-ADD/SLT/SLTU
AND/OR/XOR
SLL/SRL
SUB/SRA

2-
ADDI/SLTI[U]
ANDI/ORI/XORI

3- SLLI
SRLI
SRAI

The operations need ALU 

R-TYPE
||funct7  |	rs2	 |	rs1	|	funct3	|  rd	|opcode||

1. ADD
	rs1 + rs2, save result in rd 	(addition)

2. SLT
	if(rs1 <s rs2) then rd <= 1; else rd <= 0;	(comparition with signed)

3. SLTU	
	if(rs1 <u rs2) then rd <= 1; else rd <= 0;	(comparition with unsigned)

4. AND
	rs1 & rs2, save result in rd	(Bitwise operation)

5. OR
	rs1 | rs2, save result in rd	(Bitwise operation)
	
6. XOR
	rs1 ^ rs2, save result in rd	(Bitwise operation)

7. SLL 
	rs1 << rs2, save result in rd	(Bitwise operation)

8. SRL
	rs1 >> rs2, save result in rd	(Bitwise operation)

9. SUB
	rs1 - rs2, save result in rd	(subtraction)

10. SRA
	rs1 >>s rs2, right shift by the lower 5 bits of rs2, and save result in rd	(Bitwise operation)
	
I-TYPE
||		imm[11:0]	 	|	rs1	 |	funct3	|  rd	|opcode||

1. ADDI
	rs1 + immediate, save result in rd	(addition)

2. SLTI
	if(rs1 <s immediate) then rs = 1, else rs = 0 	(comparition with signed)

3. SLTIU
	if(rs1 <u immediate) then rs = 1, else rs = 0 	(comparition with unsigned)
	
4. ANDI
	rs1 & immediate, save result in rd	(Bitwise operation)
	
5. ORI
	rs1 | immediate, save result in rd 	(Bitwise operation)

6. XORI
	rs1 ^ immediate, save result in rd 	(Bitwise operation)

7. SLLI
	rs1 << immediate, save result in rd	(Bitwise operation)

8. SLRI
	rs1 >> immediate, save result in rd	(Bitwise operation)

9.SRAI
	rs1 >>s immediate, save result in rd	(Bitwise operation)
	
10.LB(U)
	rd  <= sext ( M[rs1 + sext(immediate)] [7:0]]		(address calculation)
	
11.LH(U)
	rd  <= sext ( M[rs1 + sext(immediate)] [15:0]]		(address calculation)

12.LW
	rd  <= sext ( M[rs1 + sext(immediate)] [31:0]]		(address calculation)
	
13.JALR
	t = pc+4; pc = (rs1 + sext(immediate)) & ~1; rd = t			(pc addition, Bitwise operation)
	
S-TYPE
||	imm[11:5] 	|rs2	|	rs1	 |	funct3	|  imm[4:0]	|opcode||

1.SB
	M[rs1] + sext(immediate) => rs2[7:0]		(address calculation)

2.SH	
	M[rs1] + sext(immediate) => rs2[15:0]		(address calculation)

3.SW
	M[rs1] + sext(immediate) => rs2[31:0]		(address calculation)

B-TYPE
||	imm[12]		|	imm[10:5]	| rs2 |	rs1	 |	funct3	|  imm[4:1]	|	imm[11]	|opcode||

1.BEQ
	if(rs1 == rs2) then pc += sext(immediate)			(comparition, pc addition)

2.BNE
	if(rs1 != rs2) then pc += sext(immediate)			(comparition, pc addition)

3.BLT
	if(rs1 <s rs2) then pc += sext(immediate)			(comparition, pc addition)
	
4.BGE
	if(rs1 >=s rs2) then pc += sext(immediate)			(comparition, pc addition)

5.BLTU
	if(rs1 <u rs2) then pc += sext(immediate)			(comparition, pc addition)

6.BGEU
	if(rs1 >=u rs2) then pc += sext(immediate)			(comparition, pc addition)
	
U-TYPE
||	imm[31:12]	|	rd	|	opcode	||

1.LUI
	rd = sext(immediate[31:12]<<12)						(lower 12bits zeros)

2.AUIPC
	rd = pc + sext(immediate[31:12]<<12)				(pc addition)

J-TYPE
||	imm[20]	|	imm[10:1]	|	imm[11]		|	imm[19:12]	|	rd	|	opcode	||

1.JAL
	rd = pc + 4; pc += sext(immediate) 					(address calculation)
2.JALR
	rd = pc + 4; pc = (rs1 + immediate) & ~1; rd = t	(address calculation)


ALU NO NEED 

1. Special I-TYPE

	FENCE
	
	ECALL
	
	EBREAK
	
2. HINT instructions


















			
	
